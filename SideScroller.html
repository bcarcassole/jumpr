<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>JUMPR</title>
<style>
    body {
        margin: 0;
        background: #0b0b0b;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial, sans-serif;
    }
    canvas {
        border: 3px solid white;
        background: black;
    }
</style>
</head>
<body>

<canvas id="game" width="800" height="300"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ==================================================
// AUDIO (CHROME-SAFE)
// ==================================================
let audioCtx;
let introOsc, gameOsc;
let audioUnlocked = false;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function stopMusic() {
    if (introOsc) introOsc.stop();
    if (gameOsc) gameOsc.stop();
    introOsc = gameOsc = null;
}

function startIntroMusic() {
    stopMusic();
    introOsc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    introOsc.type = "triangle";
    introOsc.frequency.value = 220;
    gain.gain.value = 0.07;
    introOsc.connect(gain).connect(audioCtx.destination);
    introOsc.start();
}

function startGameMusic() {
    stopMusic();
    gameOsc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    gameOsc.type = "sine";
    gameOsc.frequency.value = 140;
    gain.gain.value = 0.05;
    gameOsc.connect(gain).connect(audioCtx.destination);
    gameOsc.start();
}

function jumpSound() {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.setValueAtTime(300, audioCtx.currentTime);
    o.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
    g.gain.setValueAtTime(0.3, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.2);
}

function crashSound() {
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start();
}

// ==================================================
// GAME CONSTANTS
// ==================================================
const GROUND_Y = 220;
// NEW (50% height, same airtime)
const GRAVITY = 0.225;
const JUMP_FORCE = -8.5;
const CITY_SPEED = 0.3;
const CITY_ALPHA = 0.22; // more transparent
const CITY_SPACING = 110;

// ==================================================
// STATE
// ==================================================
let gameStarted = false;
let gameOver = false;
let speed = 3;
let score = 0;
let time = 0;
let cityOffset = 0;

// Player
const player = {
    x: 120,
    y: GROUND_Y,
    w: 40,
    h: 50,
    vy: 0,
    onGround: true,
    tilt: 0
};

// Background layers
let clouds = Array.from({length: 5}, () => ({
    x: Math.random() * canvas.width,
    y: 30 + Math.random() * 60,
    size: 20 + Math.random() * 20
}));

let cityX = 0;

// Obstacles
const obstacleTypes = [
    { type: "rock",     w: 45, h: 35 },
    { type: "cone",     w: 30, h: 50 },
    { type: "wall",     w: 70, h: 40 },
    { type: "hydrant",  w: 35, h: 55 }
];

let obstacle;

// ==================================================
// INPUT
// ==================================================
document.addEventListener("keydown", e => {
    if (e.code !== "Space") return;

    initAudio();

    // First-ever key press → unlock audio + intro music
    if (!gameStarted && !audioUnlocked) {
        audioUnlocked = true;
        startIntroMusic();
    }

    if (!gameStarted) {
        gameStarted = true;
        stopMusic();
        resetGame();
        startGameMusic();
        return;
    }

    if (!gameOver && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
        jumpSound();
    } else if (gameOver) {
        resetGame();
        startGameMusic();
    }
});

function resetGame() {
    gameOver = false;
    score = 0;
    speed = 3;
    player.y = GROUND_Y;
    player.vy = 0;
    player.onGround = true;
    obstacle = createObstacle();
}

function createObstacle() {
    const t = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

    return {
        type: t.type,
        w: t.w,
        h: t.h,

        // Spawn off-screen to the right
        x: canvas.width + 80,

        // Anchor to ground
        y: (GROUND_Y + player.h) - t.h
    };
}

// ==================================================
// UPDATE
// ==================================================
function update() {
    time++;

	updateCity();
    clouds.forEach(c => {
        c.x -= 0.2;
        if (c.x < -80) c.x = canvas.width + 80;
    });

    // ⛔ Stop here if gameplay isn't active
    if (!gameStarted || gameOver) return;

    // ======================
    // Gameplay logic only
    // ======================

    player.vy += GRAVITY;
    player.y += player.vy;

    if (player.y >= GROUND_Y) {
        player.y = GROUND_Y;
        player.vy = 0;
        player.onGround = true;
        player.tilt *= 0.8;
    } else {
        player.tilt = -0.3;
    }

    obstacle.x -= speed;

    if (obstacle.x + obstacle.w < player.x - 50) {
        score++;
        speed *= 1.05;
        obstacle = createObstacle();
    }

    // Collision detection
    if (
        player.x < obstacle.x + obstacle.w &&
        player.x + player.w > obstacle.x &&
        player.y < obstacle.y + obstacle.h &&
        player.y + player.h > obstacle.y
    ) {
        gameOver = true;
        stopMusic();
        crashSound();
        startIntroMusic();
    }
}

// ==================================================
// DRAW
// ==================================================

const cityBuildings = [];

function createBuilding(x) {
    const width = 45 + Math.floor(Math.random() * 25);
    const height = 80 + Math.floor(Math.random() * 90);

    // Pre-generate window pattern
    const windows = [];
    const rows = Math.floor(height / 18);
    const cols = Math.floor(width / 14);

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (Math.random() > 0.5) {
                windows.push({ r, c, warm: Math.random() > 0.5 });
            }
        }
    }

    return { x, width, height, windows };
}

// Initialize enough buildings to fill screen + buffer
const buildingCount = Math.ceil(canvas.width / CITY_SPACING) + 3;
for (let i = 0; i < buildingCount; i++) {
    cityBuildings.push(createBuilding(i * CITY_SPACING));
}

function updateCity() {
    cityBuildings.forEach(b => b.x -= CITY_SPEED);

    // Recycle buildings that move off screen
    if (cityBuildings[0].x + cityBuildings[0].width < 0) {
        const old = cityBuildings.shift();
        const last = cityBuildings[cityBuildings.length - 1];
        old.x = last.x + CITY_SPACING;
        cityBuildings.push(old);
    }
}

function drawCity() {
    ctx.save();
    ctx.globalAlpha = CITY_ALPHA;

    const groundY = GROUND_Y + player.h;

    cityBuildings.forEach(b => {
        const topY = groundY - b.height;

        // Building body
        ctx.fillStyle = "#1f2433";
        ctx.fillRect(b.x, topY, b.width, b.height);

        // Windows (pre-generated, stable)
        b.windows.forEach(w => {
            ctx.fillStyle = w.warm
                ? "rgba(255,220,140,0.55)"
                : "rgba(180,220,255,0.45)";

            ctx.fillRect(
                b.x + 8 + w.c * 14,
                topY + 10 + w.r * 18,
                6,
                8
            );
        });
    });

    ctx.restore();
}

function drawClouds() {
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    clouds.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.arc(c.x + c.size, c.y + 5, c.size * 0.8, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawPlayer() {
    ctx.save();
    ctx.translate(player.x + 20, player.y + 40);
    ctx.rotate(player.tilt);
    ctx.translate(-20, -40);

    // Skateboard
    ctx.fillStyle = "#2ecc71";
    ctx.beginPath();
    ctx.roundRect(0, 45, 60, 10, 5);
    ctx.fill();

    // Wheels
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(10, 58, 4, 0, Math.PI * 2);
    ctx.arc(40, 58, 4, 0, Math.PI * 2);
    ctx.fill();

    // Legs
    ctx.fillStyle = "#1f5ed6";
    ctx.fillRect(18, 30, 6, 15);
    ctx.fillRect(28, 30, 6, 15);

    // Shirt
    ctx.fillStyle = "#fff";
    ctx.fillRect(14, 15, 24, 18);

    // Arms
    ctx.fillStyle = "#f2c9a0";
    ctx.fillRect(10, 17, 4, 14);
    ctx.fillRect(38, 17, 4, 14);

    // Head
    ctx.beginPath();
    ctx.arc(26, 8, 8, 0, Math.PI * 2);
    ctx.fill();

    // Backwards cap
    ctx.fillStyle = "#e53935";
    ctx.beginPath();
    ctx.arc(26, 6, 9, Math.PI, 0);
    ctx.fill();

    ctx.restore();
}

function drawObstacle(obs) {
    switch (obs.type) {
        case "rock":     drawRock(obs); break;
        case "cone":     drawCone(obs); break;
        case "wall":     drawBrickWall(obs); break;
        case "hydrant":  drawHydrant(obs); break;
    }
}

function drawRock(o) {
    ctx.save();
    ctx.translate(o.x + o.w / 2, o.y + o.h / 2);

    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath();
    ctx.moveTo(-o.w/2, 0);
    ctx.quadraticCurveTo(-o.w/3, -o.h/2, 0, -o.h/2);
    ctx.quadraticCurveTo(o.w/2, -o.h/3, o.w/2, 0);
    ctx.quadraticCurveTo(o.w/3, o.h/2, 0, o.h/2);
    ctx.quadraticCurveTo(-o.w/2, o.h/3, -o.w/2, 0);
    ctx.fill();

    // Highlight
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(-o.w/6, -o.h/6, o.w/6, o.h/8, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function drawCone(o) {
    ctx.save();
    ctx.translate(o.x, o.y);

    // Base
    ctx.fillStyle = "#c0392b";
    ctx.fillRect(0, o.h - 8, o.w, 8);

    // Cone
    ctx.fillStyle = "#f39c12";
    ctx.beginPath();
    ctx.moveTo(o.w / 2, 0);
    ctx.lineTo(o.w, o.h - 8);
    ctx.lineTo(0, o.h - 8);
    ctx.closePath();
    ctx.fill();

    // Stripe
    ctx.fillStyle = "#fff";
    ctx.fillRect(o.w * 0.2, o.h * 0.45, o.w * 0.6, 5);

    ctx.restore();
}

function drawBrickWall(o) {
    ctx.save();
    ctx.translate(o.x, o.y);

    ctx.fillStyle = "#8e5a2b";
    ctx.fillRect(0, 0, o.w, o.h);

    // Brick pattern
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 1;

    const brickH = 10;
    const brickW = 20;

    for (let y = 0; y < o.h; y += brickH) {
        for (let x = (y / brickH) % 2 ? 0 : -brickW/2; x < o.w; x += brickW) {
            ctx.strokeRect(x, y, brickW, brickH);
        }
    }

    ctx.restore();
}

function drawHydrant(o) {
    ctx.save();
    ctx.translate(o.x + o.w / 2, o.y);

    // Body
    ctx.fillStyle = "#c0392b";
    ctx.fillRect(-o.w/4, o.h * 0.2, o.w/2, o.h * 0.6);

    // Top dome
    ctx.beginPath();
    ctx.arc(0, o.h * 0.2, o.w/3, Math.PI, 0);
    ctx.fill();

    // Side nozzles
    ctx.fillRect(-o.w/2, o.h * 0.35, o.w/4, o.h * 0.15);
    ctx.fillRect(o.w/4, o.h * 0.35, o.w/4, o.h * 0.15);

    // Base
    ctx.fillRect(-o.w/3, o.h * 0.8, o.w * 0.66, o.h * 0.15);

    // Highlight
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    ctx.fillRect(-o.w/6, o.h * 0.3, o.w/12, o.h * 0.4);

    ctx.restore();
}

function drawStartScreen() {
    ctx.fillStyle = "#0f2027";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const bounce = Math.sin(time * 0.05) * 6;
    ctx.fillStyle = "#fff";
    ctx.font = "72px Arial Black";
    ctx.fillText("JUMPR", 260, 140 + bounce);

    ctx.font = "20px Arial";
    ctx.globalAlpha = 0.6 + Math.sin(time * 0.1) * 0.4;
    ctx.fillText("Press Spacebar to Start", 265, 190);
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!gameStarted) {
        drawStartScreen();
        return;
    }

    ctx.fillStyle = "#87ceeb";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawCity();
    drawClouds();

    ctx.fillStyle = "#444";
    ctx.fillRect(0, GROUND_Y + player.h, canvas.width, 40);

    drawPlayer();

	drawObstacle(obstacle);

    ctx.fillStyle = "#000";
    ctx.font = "18px Arial";
    ctx.fillText("Score: " + score, 10, 25);

    if (gameOver) {
        ctx.font = "32px Arial";
        ctx.fillText("Game Over", 310, 130);
        ctx.font = "18px Arial";
        ctx.fillText("Press Space to Restart", 290, 165);
    }
}

// ==================================================
// LOOP
// ==================================================
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}


loop();
</script>

</body>
</html>
